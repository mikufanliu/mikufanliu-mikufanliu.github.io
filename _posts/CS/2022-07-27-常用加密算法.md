---
layout:     post
title:      "常用加密算法"
subtitle:   "Common encryption algorithms"
date:       2022-07-27 00:18:00
author:     "LabMemZero"
catalog: false
header-style: text
tags:
  - CS
  - 笔记
  - 加密算法
---

## Hash 算法

Hash 算法是一个非常重要，而且常见的算法，是计算机密码学中的核心组成部分。密码学**Hash 算法是指将任何长度的二进制值映射成较短的固定长度二进制值的算法，这个较短的固定长度二进制值就是 Hash 值。**

既然很长的输入可以变成很短的输出，这就像我们写文章之后，需要写一个摘要一样，所以 Hash 值很多时候也叫做 “消息摘要”， Java 中计算密码学 Hash 值的基类更是直接叫  MessageDigest。

### 应用场景

- **数据一致性**：第一种就是文件的比较，经常可以在各种软件下载的地方都会提供该文件的 Hash 值以及对应的 Hash 算法，这样就可以在本地验证文件是否完整下载下来。

- **数字签名**：很多地方都会用到数字签名，比如 SSL 证书，或者是 JWT，这里面都需要对原始数据计算 Hash，并进行加密处理。

- **身份验证**：前面提到密码学 Hash 算法必须具备有单向性，也就是不可逆，不能从 Hash 值逆向推算出原始值，基于这种特性，我们可以用来进行用户身份验证。

  用户登录都需要进行用户名密码的校验，如果我们将用户密码存在数据库里面，一旦数据库泄露，那就所有人的密码都泄露了！那么如果我们将用户的原始密码进行 Hash 运算，并只是把 Hash 值保存在数据库里面，当用户登录时，我们计算用户输入密码的 Hash 值，并与数据库的 Hash 值进行比较，如果相同则验证通过，不同则失败。而用户的明文密码不进行保存，这样一来，万一数据库泄露了，也不会一下子泄露了全部的用户密码。

- **文件秒传**：如何实现云盘上传一部 1-2G 的电影，结果几秒就上传成功？其中的一种实现方式就是 Hash 值的计算，在上传之前，客户端先计算出要上传文件的 Hash 值，然后将这个值发送回后台，后台检查是否已经存在该 Hash 值，如果已经存在，则告诉客户端说存在相同的文件，无需再上传，并且把对应的文件 ID 发给客户端就行，这样客户端就实现了秒传，同时也可以在服务器看到这个文件!

### MD5

**MD5**（Message Digest #5）： 是 MIT 教授 1992 年公开一种 Hash 算法，它**接收任意长度的输入，固定输出一个 128 位的 Hash 值**。MD5 算法已经被明了可以产生碰撞，也就是不同内容算出相同的 Hash 值，但是单一性还是有的，而且它的输出是常见的 Hash 算法里面最短的，因此也可以使用。

### SHA

- SHA-1：SHA-1 类似于 MD5 的算法， 输出的长度固定位 160 位，也被证明不安全。

- SHA-2：SHA-2 可以说是 SHA-1 的升级版，Hash 的构造跟实现也不同。SHA-1 是固定 160 位，而 SHA-2 可以是 224， 384， 256， 512 位，分别对应的算法名字是  SHA-224，SHA-256，SHA-384，SHA-512。

  **SHA-2 截止目前安全的，其中 SHA-256 是数字证书 SSL 的标准 Hash 算法，所以如果没有特殊的要求，建议采用 SHA256 作为 Hash 算法的首选。**

- SHA-3：SHA-2 和SHA-1使用相同的处理引擎， 所以理论上都存在碰撞的风险。Keccak 算法是 SHA-3 的标准算法。现在很多产品应用已经开始使用 SHA-3 作为 Hash 算法，比如区块链实现以太坊 Ethereum 的基础 Hash 算法就是 SHA-3。

  SHA3 对应的 4 种位数的算法名字为： SHA3-224，SHA3-256， SHA3-384，SHA3-512。

### 彩虹表

Hash 算法不可逆的特性都还没被打破，也就是基本没办法从 Hash 值反推出原始消息。反推不行，那我就干脆「正推」。如果有一个 Hash 值的表，里面包含了原文以及 Hash 值，如果我的 Hash 值跟你系统的 Hash 值一样，那我就可以知道你的密码是什么了！这个表就叫做`彩虹表（rainbow table）`。

### Hash 加盐

- 静态盐：既然常见的密码 Hash 很容易被推算出来，那么我可以在原来密码的基础上，加上一些其它字符串再计算 Hash，当验证的时候我也在用户输入的密码加上对应的字符串再进行验证，这样别人再反推就很难了。

  使用静态盐有一个潜在问题，如果某一个密码碰巧被猜出来了，或者盐被泄露出来，而由于其它密码也使用了相同的盐，那就它们被攻破的可能性就很大。

- 随机盐：加盐确实能很大程度地避免彩虹表攻击，但是上面说到的静态盐确实存在着风险，如果每个密码都用随机生成的盐，那么即使某一个密码泄露，或者某一个盐泄露了，受影响也只是一个密码而已，其它密码基本都还安全。这样随机生成的盐就叫做「随机盐」，其实就是一串随机字符。

- 盐的存储：既然每一密码都有一个独立的盐，那么这个盐该怎么存呢？ 

  如果条件允许，把盐也独立存放在一张表，这样即使密码表泄露了，盐表没泄露，那么基本还是安全的。但这样就随着带来了性能问题，毕竟每次身份验证都需要查询两张表。如果担心性能，可以把盐跟密码存在同一张表，这样身份验证的时候就只需要查询一张表，当然随着而来就是表泄露的时候同时泄露了密码 Hash 跟盐值。不过话说回来，即使拿到 Hash 以及盐，也彩虹表攻击的难度也增大了很多，你需要知道加盐的算法，然后把整个彩虹表重新算一遍 Hash 值。

  还有一种是不额外产生盐，而是用用户表中的已有字段，通过自己的算法产生一个盐，然后进行 Hash 计算。比如用 ID+Email 的 Hash 值作为盐值等等。这些都可以自己很方便地实现!

### HMAC

**HMAC**（Hash-base Message Authentication Code）：基于 Hash 的消息验证码。从名字就可以看出它主要是用来验证消息的一致性以及真实性。HMAC 算法的基本思想也跟加盐类似，只不过实现方式不同。加盐算是简单粗暴地把原文跟盐加在一起进行 Hash运算，而 **HMAC 则是将密码 key 补位，然后与明文分组进行异或运算，并且将该输出与下一个分组进行异或运算，直到算出最后的 Hash 值**。

## 加密算法

### 数据加密及类型

数据加密，指的是根据一定规则，将数据处理成不规则的数据，使得人们除非有了关键的钥匙以及得知这个规则，难于得知无规则数据的真实含义。这个`一定规则` 就是加密算法，这个`钥匙`就是密钥。

- 对称密钥加密： 双方共同持有这个密钥，发送方用这个密钥按照指定的算法将数据加密，再发出去；接收方用这个密钥将接收到的数据解密，以得到真实的数据含义。由于双方都持有这个密钥，而且内容相同，所以叫对称密钥
- 非对称密钥加密：这种加密方式的密钥是一对，发送方用其中的一把钥匙将数据加密，再发出去；接收方用这对密钥的另一把钥匙将数据解密，以得到真实的数据含义。两把钥匙不一样，所以叫做非对称密钥加密，也叫做公开密钥算法。

### 对称密钥加密

#### 分类

- 流密码算法：流密码加密是指将明文信息按字符（具体是按二进制位）逐位地加密的一类密码学算法。但是流密码算法有个问题：如果原始 key 不变的话，之前的密文很容易被破解。
- 块密码算法：块密码（Block Cipher）算法加解密的时候，不是一次性完成，而是把原文分成固定长度的块，每次对这些数据块进行处理。所以块密码算法也叫分组密码算法。

#### 块块密码算法

- **DES** （Data Encryption Standard）： 1977 年美国采用了 IBM 公司设计的加密方案作为正式的数据加密标准，起名为 DES。 DES 是分组密码算法的一种，它的 key 是 64bits。
- **3DES**：随着时间的推移，摩尔定律持续生效，64 位的密钥被破解的风险很高。而设计一种新密码算法又需要很长的时间，进行实际应用论证就更长了。所以不能轻易放弃 DES。既然它长度不够，那么我们就扩展它密钥长度。一个 64 位的密钥不够长，那我就弄出 3 个64bits：K1，K2，K3。把密钥变成 Key = EK3(DK2(EK1))。所以这个算法叫 3DES。这个算法基本解决了 DES 算法密钥长度不够的问题，但也引来了新的问题，同一个明文需要加密3次才能得出结果，性能自然而然就降下来了。
- **AES**（Advanced Encryption Standard）：AES支持128、192 和 256位数的密钥。<u>目前大部分的加密场景下都使用了AES，推荐使用AES进行加密。</u>

### 非对称加密算法 RSA

RSA 算法是由 Ron Rivest， Adi Shamir，Leenard Aldeman 三个人创建的，以他们三个人的首字母来命名 RSA。

#### 特点

- **密钥是一对**：公开密钥算法则不同，它的密钥是一对的，分成公钥（public key）和私钥 （private key）。一般私钥是由密钥对的生成者持有，比如服务器端，不能泄露。而公钥是任何人都可以持有，是公开发布的，不怕泄露。由此这个算法而得到 `公开密钥`算法的名号。
- **运行速度慢**：相对于对称加密算法，公开密钥算法由于其基础运算是指数运算再求余，而为了安全，指数一般是一个比较大的数值，所以其运算非常缓慢，而且由于算法的局限，一次加密的明文块很小，所以如果要加密一个很大的明文，比如一个文件的话，那性能是惨不忍睹的。<u>所以一般情况下，会根据使用场景，只用公开密钥算法来加密对密钥保存要求更高的数据，而不是全部都用公开密钥算法来加密。</u>

## Base64

**Base64 是一种编码转换方式**，把传输数据的每个字节映射成 ASCII 码表中的某些字符，这样在传输的过程中，就不会出现乱码的问题了。

所谓 Base64，就是说选出 64 个字符：小写字母 a-z、大写字母 A-Z、数字 0-9、符号`+`、`/`（再加上作为垫字的`=`，实际上是65个字符）作为一个基本字符集。然后，其他所有符号都转换成这个字符集中的字符。

加密过程：将每三个字节作为一组，一共 24 位分成每 6 位一组前面补充两个 0，就得到了 32 位四个字节。每个字节对应一个 Base64 字符。

字节数不足 3 的处理：2 个字节 16 位也每 6 位一组，分成 6、6、4，不足 6 位的末尾补充两个 0，再在每一组前面补充 0 映射成对应编码，完成后添加一个 = 表示缺一个字节。一个字节时， 第一组 6 位，第二组 2 位末尾补充 4 个 0 后分别在前面添加 2 个 0 后映射编码，最后添加 2 个 = 表示缺少2个字节。总结就是，如果 6 个比特少了一位就使用一个  0 填充。若是少了一个字节，用一个 = 代替。

**Base64 将 3 个字节转化成 4 个字节，因此 Base64 编码后的文本，会比原文本大出三分之一左右。**

## Base64URL

Base64URL 跟 Base64 基本类似，但有一些小的不同。有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有 3 个字符`+`、`/`和`=`，在 URL 里面有特殊含义，所以要被替换掉：`=` 被省略、`+` 替换成 `-`，`/` 替换成 `_` 。

## 参考

- [Base64笔记](https://www.ruanyifeng.com/blog/2008/06/base64.html)
- [一文密码学系列](https://blog.csdn.net/notechsolution/category_10030983.html)