---
layout:     post
title:      "联盟礼物数据迁移"
subtitle:   "Alliance Gift Data Transfer"
date:       2022-07-23 21:39:00
author:     "LabMemZero"
catalog: false
header-style: text
tags:

  - Java
  - 游戏开发
---

## 背景

离开学校，工作也一年多了，业务中一些模块还是没有实际上手过。这次有一个刚好有一个任务接触到了游戏联盟服部分的业务开发，在开发过程中消除了很多模糊的地方，review 时候大家给了很多意见，我对联盟服的上线流程有了清晰的认识。收获颇多，记录一下。

## 问题原因

本次的任务描述很简单：把游戏中联盟礼物数据存储从游戏服改到联盟服。

联盟礼物如何获得的呢，游戏中同一个联盟的成员通过攻击特定的怪物，购买特定礼包以及升级联盟科技会给联盟的每一个人添加一个礼物，玩家可以通过点击领取礼物获得奖励同时给联盟增加经验。

之所以会有这个任务是因为在游戏服务器缓存中存在大量很久未登陆玩家的缓存，正常是不会缓存这么多不活跃用户的数据的，排查发现由于添加联盟礼物导致的。

 当一个用户出发添加添加礼物这个行为时除了给自己添加一条礼物数据外，还会把这个事件通知到联盟服务器，联盟服务器找出本联盟所有成员所在的游戏服务器后回调到各个游戏服务器，给每一个成员添加一条礼物数据并推送消息。这个过程拉取了所有成员的数据，这样就会存在一个联盟几百个人，可能只有几个人在玩，其他成员很久都不登录了，也把他们拉取到内存了。

## 解决方案

解决这个问题简单的方式是添加的时候从缓存取一下用户数据取得到就加，缓存中没有的直接根据 `uid` 插入到用户数据表中，不再拉取用户数据。但是这样还是会给每个人都加一条礼物数据，对性能也有消耗。想要彻底解决这个问题，最好的办法是直接把数据放到联盟服，一个礼物只有一条数据。

### 数据库字段

把数据存储到联盟服可能数据库需要的字段肯定有变化，存在游戏服的礼物数据字段有七个字段分别是礼物唯一 id、uid、礼物配置 id、创建时间、过期时间、附加信息、领取状态。

如果要存储到联盟的话只有一条数据，如何确定某个人是否有该礼物呢，通过比成员较入盟时间和礼物的创建时间可以确定玩家是否拥有该礼物。而领取状态通过则存储一个已领取 uid 列表字段，如果玩家 uid 在其中则已经领取了。所以存放在联盟的礼物数据表字段可以确定为：礼物唯一 id、联盟 id、礼物配置 id，创建时间、过期时间、附加信息、已经领取 uid 列表。

### 接口和调用

游戏中现有礼物的接口也不多，一个获取玩家所有礼物信息的接口，一个根据礼物 id 领取奖励的接口和一个根据礼物类型批量领取奖励的接口。

第一更改的地方就是找到所有添加礼物的点，使用新的方式直接添加礼物数据到联盟，联盟服回调游戏后仅仅给在线联盟成员推送一条消息即可。

获取礼物信息倒是直接把通过玩家联盟 id 和 入盟时间把玩家信息全部查出来。领取的时候需要先知道礼物的信息做一些判断和其他操作，所以得来联盟查询数据，根据 id 查还好直接能唯一确定。根据类型就不太方便了，因为类型是要通过礼物的配置 id 查询配置表然后才知道类型的。

前联盟服务器同时对多个游戏服提供服务，联盟服是不能够重启的，只能通过热更新的方式更新，新增配置表读取配置的方式目前是不支持的。所以根据类型查询的时候我就直接返回了所有未领取的，游戏服拿到数据再根据配置表查询类型过滤吧。

之前在游戏服领取完毕礼物后回调用联盟服给联盟加经验，现在在记录领取时可以一并添加了，不用再多一次 RPC 调用。最理想的情况是领取礼物时查询这一次 RPC 调用可以省略，逻辑都放到联盟处理，返回给游戏服奖励结果就可以。

两种领取方式对联盟来说没有差别，所以记录领取就设计一个接口传礼物 id 列表就可以了。

## 遇到问题

### json 序列化

目前来看改造已经完成了，跑起来测试的时后发现领取时候出现了错误，领取完了不显示已经领取。 断点发现是领取列表判定存在的时候失败了，列表里面对 uid 是 `Integer` 类型的。记录领取礼物的 uid 列表用的是项目中的 json 数组对象，存入数据库时转换为 `String`。为什么在联盟服是 `Long` 的 uid 在游戏服序列化出来后就变成 `Integer` 了？

项目中 json 数组类型 `ISArray` 使用的一个 `List<Object>` 来存储数据，解析的使用的是 jackson，jackson 在解析的时有这样一段代码：

```java
protected void _parseNumericValue(int expType) throws IOException{
    // Int or float?
    if (_currToken == JsonToken.VALUE_NUMBER_INT) {
        int len = _intLength;
        // First: optimization for simple int
        if (len <= 9) { 
            int i = _textBuffer.contentsAsInt(_numberNegative);
            _numberInt = i;
            _numTypesValid = NR_INT;
            return;
        }
        if (len <= 18) { // definitely fits AND is easy to parse using 2 int parse calls
            long l = _textBuffer.contentsAsLong(_numberNegative);
           // ...
        }
    }
  // ...
}
```

长度小于等于 9 的按照 int 解析，10 到 18 的按照 long 解析。查了一下不光 jackson，gson 和fastjson 也都有这样的问题。除了` Long`，`Float` 反序列化时也会有类似的问题。

那就使用明确的数据类型 `List<long> ` 来记录领取的 uid，存储的时候使用`StringUtils.join(receivedUidArr, ",")`拼接成字符串存储，解析的时候使用明确的类型转换转换成 `Long`。

### 老数据兼容

如何兼容老的数据，想到了这么几个处理方式：

1. 提供一个 API，上线后全服调用一下，把所有人的游戏服的礼物给发了。这样优点是不会在代码中混杂老的礼物数据处理逻辑，缺点是玩家感知明显，还存在集中处理数据量过大的问题，同时不去点击领取或者不登陆的玩家都获得了礼物奖励；
2. 登陆时处理老数据，在玩家登陆后，处理老的礼物数据，把老的礼物奖励给发了。比起方案一不登陆的用户数据就不用处理了，也避免了集中处理数据。但还是不够好，因为获取道具玩家从点击或得变成了登陆就给。而且这个登陆处理也属于临时代码每次登陆都要进行这个检测，在登陆的时候做临时数据处理也很不合适；
3. 接口兼容老的数据，礼物信息看的不变，领取时单个领取游戏服有该礼物数据就走老的礼物领取逻辑。根据类型批量领取游戏服只要这个类型的未领取礼物数据就走老的领批量领取逻辑，否则走新的。这样来看影响时最小的，只有玩家批量领取的时候每个类型可能会遇到批量领取 10 个，结果只领取了 3 个，需要再点击领取剩下的。

综合考虑以及征求策划意见后，方案三接受度是最高的。现在不会在游戏服产生老的礼物数据了，礼物还有过期时间，过期后就不可见且会被删除。等到上线一个版本后的下一个版本，游戏服老的礼物就全部过期了，此时再把接口临时兼容代码去掉，并完全废弃老的礼物代码。

## review 出的问题

测试了没问题后赶紧请几位前辈帮忙 review 一下，分别 review 出了一堆不同的问题，现在来看确实是槽点满满。

### 并发处理

没有并发处理，添加的时候，领取礼物的也是一样的存在多个人同时领取某一礼物同时修改 `list`，我用的 `ArraryList` 缓存的 uid 列表在是会有并发问题的；

### `contains` 性能

在判断是否领取时使用的 `contains` 方法，从未仔细想过 `list` 和 `set` 的 `contains` 方法的效率问题。

看一下 `HashSe`t 的 `contains` 方法：

```java
public boolean contains(Object o) {
    return map.containsKey(o);
}
```

再看 `ArrayList` 的：

```java
public boolean contains(Object o) {
    return indexOf(o) >= 0;
}
public int indexOf(Object o) {
        if (o == null) {
            for (int i = 0; i < size; i++)
                if (elementData[i]==null)
                    return i;
        } else {
            for (int i = 0; i < size; i++)
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
}
```

`ArrayList` 每次都要遍历,这个判断调用又是非常频繁的，很可能造成卡顿。

最后改用了 `ConcurrentHashSet`，既可以避免再查询的加锁解决并发，又提高了判断是否存在的效率。

### 数据冗余

获取数据的时候我是把联盟数据表建立的实体都传输了过去，然后在游戏服建立这个实体最后转换成前端数据。其实很多数据是没有必要的，比如联盟 id 这个字段，还有已经领取了的 uid 列表完全没有必要传输回去，直接根据 uid 判断存在不存在把状态传输回去就好了。

再增加一个礼物的 view 类型，只传输游戏服需要的数据。加了这个 view 类后我把这个类放到了游戏服的包中，我的理解是游戏服这边不用联盟礼物这个对象数据，游戏这边只有 view。view 每次从 json 中新建，联盟查询结果转换成 view。review 建议是我因该放到联盟服包中，而且还应该提供一个静态转换方法，传入一个联盟礼物对象获得一个view对象，以后添加或者更改字段，我不用既要去联盟礼物的 `toJson` 方法加字段，又要在 view 的 `newFomJson` 加字段。既要改联盟部分代码又要改游戏部分代码，很容易遗漏和出错。都放到联盟每个字段对应更改更方便。

### 领取优化

虽说是领取的时候要先去联盟服查询数据暂时无法改变，但是查询是有优化空间的。领取查询的礼物肯定是要未领取的，没有超时的，这些都可以在联盟服过滤。根据型领取的时候，有的类型是限制了不同的数量的。这样一想所有的过滤都可以放在联盟服处理，不符合的数据传输回去干嘛。

联盟服没有办法读取礼物配置无法获取类型，看来加一个字段是很有必要的，当时考虑到的是如果配置表变更那么已经存储的礼物数据类型就不匹配了，现在来看这个配置直接把类型改了的几率几乎为 0，而且就算改了已经生成的类型不变这个设定也是可以接受的。加了类型字段后，所有的过滤都放在联盟服，每次领取查询到的数据一定是可以领取的。

## 总结

功能山线的时候还是很忐忑的，平时都没有动过联盟服的代码，而且对游戏服和联盟服互相调用有些模糊。好在最后平稳上线，对整个联盟服热更流程熟悉了一遍。前辈们帮忙 review 代码，给了很多意见，甚至包扩命名该叫 `service` 还是 `manager` 都讨论了一番，有很多地方我平时是没有意识到的，使我受益匪浅。

后续等到联盟服支持配置读取的热更新，考虑把领取的逻辑完全移动到联盟服，不在需要先在游戏服调用联盟服查询。